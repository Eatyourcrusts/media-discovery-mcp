#!/usr/bin/env node

/**
 * Media Discovery MCP Server
 * Provides advanced search and discovery capabilities for media companies and ad formats
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import { createClient } from '@supabase/supabase-js';

// Supabase configuration
const SUPABASE_URL = 'https://nlrbtjqwjpernhtvjwrl.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5scmJ0anF3anBlcm5odHZqd3JsIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTQzNzgyMzMsImV4cCI6MjA2OTk1NDIzM30.eNuvT_gH9CrV2kYh50E3GD2hHG2P_DY8r-KgshJwK94';

const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// OpenAI configuration for embeddings
const OPENAI_API_KEY = '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';

class MediaDiscoveryServer {
  constructor() {
    this.server = new Server(
      {
        name: "media-discovery-server",
        version: "1.0.0",
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    this.setupToolHandlers();
    this.setupErrorHandling();
  }

  setupErrorHandling() {
    this.server.onerror = (error) => {
      console.error("[MCP Error]", error);
    };

    process.on("SIGINT", async () => {
      await this.server.close();
      process.exit(0);
    });
  }

  setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: "semantic_search_companies",
            description: "Search for media companies using natural language queries with semantic similarity",
            inputSchema: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "Natural language search query (e.g., 'CTV platforms with gaming ads')"
                },
                limit: {
                  type: "number",
                  description: "Maximum number of results to return",
                  default: 5
                },
                filters: {
                  type: "object",
                  description: "Optional filters to apply",
                  properties: {
                    business_type: {
                      type: "string",
                      description: "Filter by Company or Agency"
                    },
                    geographic_markets: {
                      type: "array",
                      description: "Filter by geographic availability"
                    },
                    media_categories: {
                      type: "array", 
                      description: "Filter by media categories"
                    }
                  }
                }
              },
              required: ["query"]
            }
          },
          {
            name: "semantic_search_ad_formats",
            description: "Search for advertising formats using natural language with semantic similarity",
            inputSchema: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "Natural language search query (e.g., 'interactive gaming ad formats')"
                },
                limit: {
                  type: "number",
                  description: "Maximum number of results to return",
                  default: 5
                },
                filters: {
                  type: "object",
                  description: "Optional filters to apply",
                  properties: {
                    company_name: {
                      type: "string",
                      description: "Filter by specific company"
                    },
                    media_categories: {
                      type: "array",
                      description: "Filter by media categories"
                    },
                    minimum_spend_range: {
                      type: "object",
                      properties: {
                        min: { type: "number" },
                        max: { type: "number" }
                      }
                    }
                  }
                }
              },
              required: ["query"]
            }
          },
          {
            name: "hybrid_search",
            description: "Advanced search combining semantic similarity and keyword matching across companies and ad formats",
            inputSchema: {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "Search query to process"
                },
                search_type: {
                  type: "string",
                  enum: ["companies", "ad_formats", "both"],
                  description: "What to search for",
                  default: "both"
                },
                limit: {
                  type: "number",
                  description: "Max results per category",
                  default: 5
                }
              },
              required: ["query"]
            }
          },
          {
            name: "get_company_details",
            description: "Get comprehensive details about a specific media company including ad formats",
            inputSchema: {
              type: "object",
              properties: {
                company_id: {
                  type: "string",
                  description: "Company UUID or business name"
                },
                include_ad_formats: {
                  type: "boolean",
                  description: "Whether to include company's ad formats",
                  default: true
                }
              },
              required: ["company_id"]
            }
          },
          {
            name: "compare_entities", 
            description: "Compare multiple companies or ad formats side by side",
            inputSchema: {
              type: "object",
              properties: {
                entity_type: {
                  type: "string",
                  enum: ["companies", "ad_formats"],
                  description: "Type of entities to compare"
                },
                entity_ids: {
                  type: "array",
                  description: "Array of entity IDs or names to compare",
                  minItems: 2,
                  maxItems: 5
                },
                comparison_fields: {
                  type: "array",
                  description: "Specific fields to compare (optional)",
                  items: {
                    type: "string"
                  }
                }
              },
              required: ["entity_type", "entity_ids"]
            }
          },
          {
            name: "discovery_analytics",
            description: "Get analytics and insights about search patterns, popular companies, trending formats",
            inputSchema: {
              type: "object",
              properties: {
                analytics_type: {
                  type: "string",
                  enum: ["popular_companies", "trending_formats", "search_patterns", "market_overview"],
                  description: "Type of analytics to retrieve"
                },
                time_period: {
                  type: "string",
                  enum: ["7d", "30d", "90d", "all"],
                  description: "Time period for analytics",
                  default: "30d"
                }
              },
              required: ["analytics_type"]
            }
          }
        ]
      };
    });

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          case "semantic_search_companies":
            return await this.semanticSearchCompanies(args);

          case "semantic_search_ad_formats":
            return await this.semanticSearchAdFormats(args);

          case "hybrid_search":
            return await this.hybridSearch(args);

          case "get_company_details":
            return await this.getCompanyDetails(args);

          case "compare_entities":
            return await this.compareEntities(args);

          case "discovery_analytics":
            return await this.getDiscoveryAnalytics(args);

          default:
            throw new Error(`Unknown tool: ${name}`);
        }
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error executing ${name}: ${error.message}`
            }
          ],
          isError: true,
        };
      }
    });
  }

  // Generate OpenAI embedding for semantic search
  async generateEmbedding(text) {
    try {
      const response = await fetch('https://api.openai.com/v1/embeddings', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${OPENAI_API_KEY}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'text-embedding-3-small',
          input: text
        })
      });

      const data = await response.json();
      return data.data[0].embedding;
    } catch (error) {
      console.error('Error generating embedding:', error);
      throw error;
    }
  }

  async semanticSearchCompanies(args) {
    const { query, limit = 5, filters = {} } = args;
    
    try {
      // Generate embedding for the query
      const queryEmbedding = await this.generateEmbedding(query);
      
      // Build the search query
      let searchQuery = supabase
        .from('companies_searchable')
        .select(`
          id,
          business_name,
          description,
          business_type,
          website,
          media_categories,
          audience_targeting,
          geographic_markets,
          embedding
        `)
        .order('id'); // We'll sort by similarity after getting results

      // Apply filters
      if (filters.business_type) {
        searchQuery = searchQuery.eq('business_type', filters.business_type);
      }

      if (filters.geographic_markets) {
        searchQuery = searchQuery.overlaps('geographic_markets', filters.geographic_markets);
      }

      if (filters.media_categories) {
        searchQuery = searchQuery.overlaps('media_categories', filters.media_categories);
      }

      const { data: companies, error } = await searchQuery.limit(limit * 2); // Get more for similarity ranking

      if (error) throw error;

      // Calculate similarity scores and sort
      const companiesWithSimilarity = companies
        .map(company => ({
          ...company,
          similarity: this.cosineSimilarity(queryEmbedding, company.embedding)
        }))
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, limit);

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              query: query,
              results: companiesWithSimilarity.map(company => ({
                id: company.id,
                business_name: company.business_name,
                description: company.description,
                business_type: company.business_type,
                website: company.website,
                media_categories: company.media_categories,
                audience_targeting: company.audience_targeting,
                geographic_markets: company.geographic_markets,
                similarity_score: company.similarity,
                match_strength: company.similarity > 0.8 ? 'high' : 
                               company.similarity > 0.6 ? 'medium' : 'low'
              })),
              total_results: companiesWithSimilarity.length,
              search_metadata: {
                filters_applied: Object.keys(filters).length,
                semantic_search: true,
                query_embedding_dimensions: queryEmbedding.length
              }
            }, null, 2)
          }
        ]
      };

    } catch (error) {
      throw new Error(`Semantic company search failed: ${error.message}`);
    }
  }

  async semanticSearchAdFormats(args) {
    const { query, limit = 5, filters = {} } = args;

    try {
      const queryEmbedding = await this.generateEmbedding(query);
      
      let searchQuery = supabase
        .from('ad_formats_searchable')
        .select(`
          id,
          format_name,
          description,
          company_name,
          media_categories,
          campaign_kpis,
          audience_targeting,
          inventory_scale,
          minimum_spend_usd,
          geographic_availability,
          embedding
        `)
        .order('id');

      // Apply filters
      if (filters.company_name) {
        searchQuery = searchQuery.ilike('company_name', `%${filters.company_name}%`);
      }

      if (filters.media_categories) {
        searchQuery = searchQuery.overlaps('media_categories', filters.media_categories);
      }

      if (filters.minimum_spend_range) {
        const { min, max } = filters.minimum_spend_range;
        if (min) searchQuery = searchQuery.gte('minimum_spend_usd', min);
        if (max) searchQuery = searchQuery.lte('minimum_spend_usd', max);
      }

      const { data: formats, error } = await searchQuery.limit(limit * 2);

      if (error) throw error;

      const formatsWithSimilarity = formats
        .map(format => ({
          ...format,
          similarity: this.cosineSimilarity(queryEmbedding, format.embedding)
        }))
        .sort((a, b) => b.similarity - a.similarity)
        .slice(0, limit);

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              query: query,
              results: formatsWithSimilarity.map(format => ({
                id: format.id,
                format_name: format.format_name,
                description: format.description,
                company_name: format.company_name,
                media_categories: format.media_categories,
                campaign_kpis: format.campaign_kpis,
                audience_targeting: format.audience_targeting,
                inventory_scale: format.inventory_scale,
                minimum_spend_usd: format.minimum_spend_usd,
                geographic_availability: format.geographic_availability,
                similarity_score: format.similarity,
                match_strength: format.similarity > 0.8 ? 'high' : 
                               format.similarity > 0.6 ? 'medium' : 'low'
              })),
              total_results: formatsWithSimilarity.length,
              search_metadata: {
                filters_applied: Object.keys(filters).length,
                semantic_search: true
              }
            }, null, 2)
          }
        ]
      };

    } catch (error) {
      throw new Error(`Semantic ad format search failed: ${error.message}`);
    }
  }

  async hybridSearch(args) {
    const { query, search_type = "both", limit = 5 } = args;

    try {
      const results = {
        query: query,
        search_type: search_type,
        companies: [],
        ad_formats: [],
        combined_insights: []
      };

      // Semantic search for companies
      if (search_type === "companies" || search_type === "both") {
        const companyResults = await this.semanticSearchCompanies({ query, limit });
        const companyData = JSON.parse(companyResults.content[0].text);
        results.companies = companyData.results;
      }

      // Semantic search for ad formats
      if (search_type === "ad_formats" || search_type === "both") {
        const formatResults = await this.semanticSearchAdFormats({ query, limit });
        const formatData = JSON.parse(formatResults.content[0].text);
        results.ad_formats = formatData.results;
      }

      // Generate insights by combining results
      if (search_type === "both") {
        results.combined_insights = this.generateCombinedInsights(results.companies, results.ad_formats, query);
      }

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(results, null, 2)
          }
        ]
      };

    } catch (error) {
      throw new Error(`Hybrid search failed: ${error.message}`);
    }
  }

  async getCompanyDetails(args) {
    const { company_id, include_ad_formats = true } = args;

    try {
      // Try to find company by ID first, then by name
      let { data: company, error } = await supabase
        .from('companies_searchable')
        .select('*')
        .eq('id', company_id)
        .single();

      if (error || !company) {
        // Try searching by business name
        const { data: companyByName, error: nameError } = await supabase
          .from('companies_searchable')
          .select('*')
          .ilike('business_name', `%${company_id}%`)
          .single();

        if (nameError || !companyByName) {
          throw new Error(`Company not found: ${company_id}`);
        }
        company = companyByName;
      }

      const result = {
        company: company,
        ad_formats: []
      };

      // Get ad formats if requested
      if (include_ad_formats) {
        const { data: formats, error: formatsError } = await supabase
          .from('ad_formats_searchable')
          .select('*')
          .eq('company_id', company.id);

        if (!formatsError) {
          result.ad_formats = formats;
        }
      }

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      throw new Error(`Failed to get company details: ${error.message}`);
    }
  }

  async compareEntities(args) {
    const { entity_type, entity_ids, comparison_fields = [] } = args;

    try {
      let tableName = entity_type === "companies" ? "companies_searchable" : "ad_formats_searchable";
      let entities = [];

      // Fetch all entities
      for (const entityId of entity_ids) {
        const { data, error } = await supabase
          .from(tableName)
          .select('*')
          .or(`id.eq.${entityId},business_name.ilike.%${entityId}%,format_name.ilike.%${entityId}%`)
          .limit(1);

        if (!error && data.length > 0) {
          entities.push(data[0]);
        }
      }

      if (entities.length < 2) {
        throw new Error(`Need at least 2 entities to compare. Found: ${entities.length}`);
      }

      // Generate comparison
      const comparison = {
        entity_type: entity_type,
        entities_compared: entities.length,
        comparison_matrix: this.generateComparisonMatrix(entities, comparison_fields),
        entities: entities
      };

      return {
        content: [
          {
            type: "text", 
            text: JSON.stringify(comparison, null, 2)
          }
        ]
      };

    } catch (error) {
      throw new Error(`Entity comparison failed: ${error.message}`);
    }
  }

  async getDiscoveryAnalytics(args) {
    const { analytics_type, time_period = "30d" } = args;

    try {
      let analytics = {};

      switch (analytics_type) {
        case "popular_companies":
          const { data: companies } = await supabase
            .from('companies_searchable')
            .select('business_name, business_type, media_categories')
            .order('business_name');
          
          analytics = {
            total_companies: companies?.length || 0,
            by_type: this.groupBy(companies, 'business_type'),
            top_media_categories: this.getTopCategories(companies, 'media_categories')
          };
          break;

        case "trending_formats":
          const { data: formats } = await supabase
            .from('ad_formats_searchable')
            .select('format_name, company_name, media_categories, inventory_scale')
            .order('format_name');

          analytics = {
            total_formats: formats?.length || 0,
            by_inventory_scale: this.groupBy(formats, 'inventory_scale'),
            top_media_categories: this.getTopCategories(formats, 'media_categories'),
            formats_per_company: this.getFormatsPerCompany(formats)
          };
          break;

        case "market_overview":
          const companiesOverview = await supabase.from('companies_searchable').select('*');
          const formatsOverview = await supabase.from('ad_formats_searchable').select('*');
          
          analytics = {
            market_summary: {
              total_companies: companiesOverview.data?.length || 0,
              total_ad_formats: formatsOverview.data?.length || 0,
              avg_formats_per_company: formatsOverview.data?.length / (companiesOverview.data?.length || 1)
            },
            company_types: this.groupBy(companiesOverview.data, 'business_type'),
            format_distribution: this.groupBy(formatsOverview.data, 'inventory_scale')
          };
          break;
      }

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              analytics_type: analytics_type,
              time_period: time_period,
              generated_at: new Date().toISOString(),
              data: analytics
            }, null, 2)
          }
        ]
      };

    } catch (error) {
      throw new Error(`Analytics generation failed: ${error.message}`);
    }
  }

  // Helper functions
  cosineSimilarity(vecA, vecB) {
    if (!vecA || !vecB || vecA.length !== vecB.length) return 0;
    
    let dotProduct = 0;
    let normA = 0;
    let normB = 0;
    
    for (let i = 0; i < vecA.length; i++) {
      dotProduct += vecA[i] * vecB[i];
      normA += vecA[i] * vecA[i];
      normB += vecB[i] * vecB[i];
    }
    
    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
  }

  generateCombinedInsights(companies, formats, query) {
    const insights = [];

    // Find companies that have formats in the results
    const companyFormatMap = {};
    formats.forEach(format => {
      if (!companyFormatMap[format.company_name]) {
        companyFormatMap[format.company_name] = [];
      }
      companyFormatMap[format.company_name].push(format);
    });

    companies.forEach(company => {
      if (companyFormatMap[company.business_name]) {
        insights.push({
          type: "company_format_match",
          company: company.business_name,
          matching_formats: companyFormatMap[company.business_name].length,
          insight: `${company.business_name} offers ${companyFormatMap[company.business_name].length} relevant formats for "${query}"`
        });
      }
    });

    return insights;
  }

  generateComparisonMatrix(entities, fields) {
    const matrix = {};
    
    // If no specific fields requested, compare key fields based on entity type
    const defaultFields = entities[0].format_name ? 
      ['format_name', 'company_name', 'media_categories', 'inventory_scale', 'minimum_spend_usd'] :
      ['business_name', 'business_type', 'media_categories', 'geographic_markets'];

    const fieldsToCompare = fields.length > 0 ? fields : defaultFields;

    fieldsToCompare.forEach(field => {
      matrix[field] = entities.map(entity => entity[field] || null);
    });

    return matrix;
  }

  groupBy(array, key) {
    if (!array) return {};
    return array.reduce((groups, item) => {
      const value = item[key];
      groups[value] = groups[value] || 0;
      groups[value]++;
      return groups;
    }, {});
  }

  getTopCategories(items, categoryField) {
    const categoryCount = {};
    items?.forEach(item => {
      const categories = item[categoryField] || [];
      categories.forEach(category => {
        categoryCount[category] = (categoryCount[category] || 0) + 1;
      });
    });
    
    return Object.entries(categoryCount)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10)
      .map(([category, count]) => ({ category, count }));
  }

  getFormatsPerCompany(formats) {
    const companyCount = {};
    formats?.forEach(format => {
      const company = format.company_name;
      companyCount[company] = (companyCount[company] || 0) + 1;
    });
    
    return Object.entries(companyCount)
      .sort(([,a], [,b]) => b - a)
      .map(([company, count]) => ({ company, format_count: count }));
  }

  async run() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error("Media Discovery MCP server running on stdio");
  }
}

const server = new MediaDiscoveryServer();
server.run().catch(console.error);
